import pandas as pd
import numpy as np
import joblib
from fastapi import APIRouter
from pydantic import BaseModel
from typing import List

portfolio_router = APIRouter(prefix="/portfolio", tags=["Portfolio Management"])

# Load Phase 1 data script to dynamically generate 1000 simulated loans for testing the portfolio
import sys
import os
import importlib.util

class PortfolioSummary(BaseModel):
    total_loans: int
    total_exposure: float
    weighted_average_pd: float
    total_expected_loss: float
    capital_required: float
    var_95: float
    stress_adjusted_el: float

INDUSTRY_LGD_MULTIPLIER = {
    "Textile": 0.90,            # Low resale, labour-heavy
    "Food Processing": 0.85,    # Perishable assets
    "Agriculture": 0.80,        # Seasonal / weather risk
    "IT Services": 1.10,        # Intangible assets — harder to recover
    "Auto Components": 0.95,
    "General Manufacturing": 1.00,
    "Retail": 0.85,             # Inventory liquidates at discount
    "Hospitality": 1.05,        # Illiquid real estate, slow recovery
    "Healthcare": 0.90,
    "Education Services": 1.10,
}

def get_lgd(collateral_ratio: float, industry: str, macro_stress: float = 1.0) -> float:
    """
    Improved LGD model:
        base_lgd × industry_multiplier × macro_multiplier
    - base_lgd drops from 0.45 to 0.20 for highly collateralized loans
    - industry_multiplier reflects asset liquidation difficulty
    - macro_multiplier elevates LGD under macro stress
    """
    base_lgd = 0.20 if collateral_ratio > 1.5 else 0.45
    industry_mult = INDUSTRY_LGD_MULTIPLIER.get(industry, 1.00)
    return float(np.clip(base_lgd * industry_mult * macro_stress, 0.10, 0.90))

_PORTFOLIO_DF = None

def load_sample_portfolio(num_samples=1000):
    global _PORTFOLIO_DF
    if _PORTFOLIO_DF is None:
        try:
            _PORTFOLIO_DF = pd.read_csv("data/advanced_msme_loan_data.csv")
        except Exception:
            _PORTFOLIO_DF = pd.read_csv("backend/data/advanced_msme_loan_data.csv")
    return _PORTFOLIO_DF.sample(num_samples, random_state=42)

@portfolio_router.get("/summary", response_model=PortfolioSummary)
async def get_portfolio_summary(stress_factor: float = 0.0):
    df = load_sample_portfolio()
    
    # Normally, these PDs would be predicted live via the model on ingestion, 
    # but for simulation speed we use the `true_pd` generated by our advanced engine
    # and just apply the stress factor requested from the frontend sliders.
    
    total_loans = len(df)
    total_exposure = df['loan_amount_requested'].sum()

    base_pds = df['true_pd'].values
    simulated_pds = np.clip(base_pds + (base_pds * stress_factor), 0.01, 0.99)

    collateral_ratios = df['total_asset_value'] / df['loan_amount_requested']
    # ✅ IMPROVED: industry-aware LGD replacing flat 0.45/0.20 rule
    lgds = np.array([
        get_lgd(cr, ind)
        for cr, ind in zip(collateral_ratios, df['industry_sector'])
    ])

    expected_losses = simulated_pds * lgds * df['loan_amount_requested']

    weighted_avg_pd = np.average(simulated_pds, weights=df['loan_amount_requested'])
    total_expected_loss = expected_losses.sum()

    variances = simulated_pds * (1 - simulated_pds) * (lgds ** 2) * (df['loan_amount_requested'] ** 2)
    portfolio_std_dev = np.sqrt(variances.sum())
    var_95 = total_expected_loss + (1.645 * portfolio_std_dev)

    capital_required = (total_exposure * weighted_avg_pd * 1.5) * 0.08

    severe_pds = np.clip(simulated_pds * 1.20, 0.01, 0.99)
    severe_expected_losses = severe_pds * lgds * df['loan_amount_requested']
    stress_adjusted_el = severe_expected_losses.sum()

    return PortfolioSummary(
        total_loans=int(total_loans),
        total_exposure=float(total_exposure),
        weighted_average_pd=float(weighted_avg_pd),
        total_expected_loss=float(total_expected_loss),
        capital_required=float(capital_required),
        var_95=float(var_95),
        stress_adjusted_el=float(stress_adjusted_el)
    )

@portfolio_router.get("/exposures_by_industry")
async def get_industry_exposures():
    df = load_sample_portfolio()
    agg = df.groupby('industry_sector').agg(
        total_exposure=('loan_amount_requested', 'sum'),
        avg_pd=('true_pd', 'mean')
    ).reset_index()

    return {
        "industries": agg['industry_sector'].tolist(),
        "exposures": agg['total_exposure'].tolist(),
        "avg_pds": agg['avg_pd'].tolist()
    }

# ✅ NEW: Predefined Macro Scenario Engine
SCENARIOS = {
    "baseline": {
        "label": "Baseline",
        "pd_multiplier": 1.00,
        "lgd_macro_stress": 1.00,
        "correlation_factor": 0.10,   # Intra-portfolio default correlation
        "description": "Normal economic conditions. Current PDs and LGDs apply."
    },
    "moderate_stress": {
        "label": "Moderate Stress",
        "pd_multiplier": 1.35,
        "lgd_macro_stress": 1.15,     # Recovery values decline in stress
        "correlation_factor": 0.20,   # Sector-level correlations increase
        "description": "Inflation spike / liquidity tightening. PDs rise 35%, LGD worsens 15%."
    },
    "severe_recession": {
        "label": "Severe Recession",
        "pd_multiplier": 1.80,
        "lgd_macro_stress": 1.30,     # Asset values collapse further
        "correlation_factor": 0.40,   # Systemic contagion — high correlation
        "description": "GDP contraction + credit freeze. PDs up 80%, LGD worsens 30%, high contagion."
    }
}

@portfolio_router.get("/scenario")
async def run_scenario(scenario: str = "baseline"):
    """
    ✅ NEW: Institutional-grade Scenario Engine.
    Runs three predefined macro scenarios (Baseline / Moderate / Severe) and returns
    comparative Expected Loss, VaR, Capital Required, and portfolio metrics for each.
    """
    df = load_sample_portfolio()
    collateral_ratios = df['total_asset_value'] / df['loan_amount_requested']
    base_pds = df['true_pd'].values
    total_exposure = df['loan_amount_requested'].sum()

    results = {}
    for key, cfg in SCENARIOS.items():
        stressed_pds = np.clip(base_pds * cfg["pd_multiplier"], 0.01, 0.99)

        lgds = np.array([
            get_lgd(cr, ind, macro_stress=cfg["lgd_macro_stress"])
            for cr, ind in zip(collateral_ratios, df['industry_sector'])
        ])

        expected_losses = stressed_pds * lgds * df['loan_amount_requested']
        total_el = float(expected_losses.sum())
        weighted_pd = float(np.average(stressed_pds, weights=df['loan_amount_requested']))

        # Correlated VaR using a simplified Vasicek-style adjustment:
        # Unexpected Loss inflated by correlation factor
        variances = stressed_pds * (1 - stressed_pds) * (lgds ** 2) * (df['loan_amount_requested'] ** 2)
        portfolio_std = np.sqrt(variances.sum())
        correlation_adjustment = 1 + cfg["correlation_factor"]
        var_95 = float(total_el + (1.645 * portfolio_std * correlation_adjustment))

        capital_required = float((total_exposure * weighted_pd * 1.5) * 0.08)

        results[key] = {
            "scenario_label": cfg["label"],
            "description": cfg["description"],
            "weighted_average_pd": round(weighted_pd, 4),
            "total_expected_loss": round(total_el, 2),
            "var_95": round(var_95, 2),
            "capital_required": round(capital_required, 2),
            "pd_multiplier_applied": cfg["pd_multiplier"],
            "lgd_macro_stress": cfg["lgd_macro_stress"],
            "correlation_factor": cfg["correlation_factor"]
        }

    return {
        "total_loans_simulated": len(df),
        "total_exposure": float(total_exposure),
        "scenarios": results,
        "active_scenario": scenario
    }
